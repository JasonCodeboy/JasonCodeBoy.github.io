(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{405:function(v,t,p){"use strict";p.r(t);var e=p(33),_=Object(e.a)({},(function(){var v=this,t=v.$createElement,p=v._self._c||t;return p("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[p("h1",{attrs:{id:"vue-源码（三）：vue"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码（三）：vue"}},[v._v("#")]),v._v(" Vue 源码（三）：Vue")]),v._v(" "),p("p",[v._v("接下来，最终调用 mergeOptions 所传的第一个参数就是 Vue.options 这个对象，第二个参数是用户自定义的 options 对象，然后第三参数是 vm。")]),v._v(" "),p("p",[v._v("我们这时候可以打印 parent 和 child 看看是什么东西：")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-1.png",alt:""}})]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-2.png",alt:""}})]),v._v(" "),p("p",[v._v("我们可以看到 parent 就是 Vue 本身的一些全局 API，然后 child 就是我们自己所传过去的 options 对象。")]),v._v(" "),p("p",[v._v("那么接下来我们应该怎么办呢？我们会在 mergeOptions 里面做两件事情，一个来做一些选项的规范，它的一些检测。另外我们还会来做一些合并。")]),v._v(" "),p("p",[v._v("那么什么叫做规范的检测？我们要检测有哪些规范？")]),v._v(" "),p("p",[v._v("首先第一个，我们要检测 components 组件名的规范，然后是 props 传值的规范，还有 inject 的规范，directives 指令的规范等等。")]),v._v(" "),p("p",[v._v("那么我们先来检测，你给我所传过来的组件，它的名称是否是规范的。")]),v._v(" "),p("p",[v._v("因为我们知道在定义组件的时候，我们组件的名称要么就是一个纯字母，要么就一定要是字母加 '-' 组成的。")]),v._v(" "),p("p",[v._v("那么我们就通过 checkComponents 方法来检测，你给我传过来的组件名是否是规范的。")]),v._v(" "),p("p",[v._v("我们可以通过遍历 options.components 来检测它的 key 一定是规范的，然后在调用 validateComponentName 这个方法来检测组件的名称是否是规范的。")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-3.png",alt:""}})]),v._v(" "),p("p",[v._v("然后接下来，我们就需要考虑，组件的名称有哪些是不能写的？")]),v._v(" "),p("p",[v._v("1，很明显，我们不能使用 Vue 内置的标签，比如 slot，component。")]),v._v(" "),p("p",[v._v("2，html 的标签不能使用。")]),v._v(" "),p("p",[v._v("3，svg 的属性名称也不能使用。")]),v._v(" "),p("p",[v._v("然后就是规范了，组件的名称必须是由字母或中横线组成，且必须是由字母开头。")]),v._v(" "),p("p",[v._v("那么我们明确了这些之后，就可以写出这三个方法都逻辑了：")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-4.png",alt:""}})]),v._v(" "),p("p",[v._v("然后我们改变一下组件 A 的名称，在前面加个下划线，就可以在控制台上面看到：")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-5.png",alt:""}})]),v._v(" "),p("p",[v._v("那么第二个检测我们应该怎么来做呢？")]),v._v(" "),p("p",[v._v("我们可以通过 isBuiltInTag 和 isReservedTag 这两个方法来做。")]),v._v(" "),p("p",[v._v("如果说这两个方法调用的时候，它们的返回值有一个是为 true，那么我们最终的结果就是报错，给出警告。")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-6.png",alt:""}})]),v._v(" "),p("p",[v._v("然后，我们定义 isBuiltInTag 方法，然后在调用 makeMap 方法的时候，我们会把你的返回值给到 isBuiltInTag，然后返回值也一定是个函数。")]),v._v(" "),p("p",[v._v("然后我们就定义 makeMap 这个函数，用来检测 key 是否在 makeMap 它的一个列表里面。")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-7.png",alt:""}})]),v._v(" "),p("p",[v._v("makeMap 方法的第一个参数 str 就是一个字符串，第二个参数就是你要不要把我当前的这个字符串变成小写。")]),v._v(" "),p("p",[v._v("然后我们可以定义一个对象，在把 str 里面所有的值都存储在这个对象里面，并且给它为 true。然后在通过传过来的标识 toLowerCase 来决定返回的匿名函数的值。")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-8.png",alt:""}})]),v._v(" "),p("p",[v._v("匿名函数的作用是检测 key 在我们这个 map 列表里面是否有这个属性，如果有直接返回出去就好了。")]),v._v(" "),p("p",[v._v("那么我们传入的 toLowerCase 有什么作用呢？")]),v._v(" "),p("p",[v._v("如果第二个参数有传 true，那么在返回的同时，我们会把所有的属性统一变成小写。")]),v._v(" "),p("p",[v._v("如果没有，那么就直接的返回当前 map 列表的值就好了")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-9.png",alt:""}})]),v._v(" "),p("p",[v._v("这时候，我们在更改下组件名称为内置组件 component，就可以看到控制台的报错信息了：")]),v._v(" "),p("p",[p("img",{attrs:{src:"/img/vueym-3-10.png",alt:""}})])])}),[],!1,null,null,null);t.default=_.exports}}]);