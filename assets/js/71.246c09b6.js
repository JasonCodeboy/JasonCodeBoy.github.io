(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{391:function(e,t,r){"use strict";r.r(t);var v=r(33),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"生命周期详解，template-解析过程，rendererror-和-errorcaptured"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期详解，template-解析过程，rendererror-和-errorcaptured"}},[e._v("#")]),e._v(" 生命周期详解，template 解析过程，renderError 和 errorCaptured")]),e._v(" "),r("p",[e._v("Vue 组件的生命周期其实也就是 Vue 对象的生命周期，我们在 new 一个 Vue 对象的过程中，其实它的生命周期就已经开始走了。")]),e._v(" "),r("p",[e._v("我们先把所有的生命周期都列出来，看一下它们的执行顺序：")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/vue-4-1.png",alt:"在这里插入图片描述"}}),e._v("\n我们看到，控制台只打印出来了 beforeCreate，created，beforeMount，mounted。")]),e._v(" "),r("p",[e._v("因此说明了我们在 new 一个 Vue 实例的过程当中，这些方法已经执行了，而且它们是有顺序的。")]),e._v(" "),r("p",[e._v("其实我们在 new 的时候，并没有执行 beforeMount 和 mounted。如果我们没有指定 el，那么我们再来看一下还会不会执行这些操作。")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/vue-4-2.png",alt:"在这里插入图片描述"}})]),e._v(" "),r("p",[e._v("我们可以看到，只执行了 beforeCreate 和 created。那么为什么呢？")]),e._v(" "),r("p",[e._v("因为我们的 mount，其实它就是把组件里面生成的 html 内容挂载到 DOM 上面的一个过程。")]),e._v(" "),r("p",[e._v("如果我们没有指定 el 这个属性，同时也不执行 app.$mount 的方法，那么它是不会挂载到 html 节点上的。")]),e._v(" "),r("p",[e._v("因为它根本就不知道它应该挂载到哪里去。所以它就不会执行这些相关的操作。")]),e._v(" "),r("p",[e._v("而 beforeCreate 和 created，在它们进行初始化的时候，就必定会执行的。")]),e._v(" "),r("p",[e._v("那么我们下面的生命周期为什么没执行呢？")]),e._v(" "),r("p",[e._v("我们先来看下 beforeUpdate 和 updated。")]),e._v(" "),r("p",[e._v("这两个是需要有数据更新的时候，才会去执行的。我们可以来试下。如下图:")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/vue-4-3.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到，每次数据更新的时候，它就会去执行 beforeUpdate 和 updated。")]),e._v(" "),r("p",[e._v("那么 beforeDestroy 和 destroyed 是什么时候执行的呢？")]),e._v(" "),r("p",[e._v("组件销毁的方法 app.$destroy()：我们主动去销毁生成出来的实例。")]),e._v(" "),r("p",[e._v("主动销毁的过程中，它会去帮我们解除所有的事件监听，以及我们所有的 watch。不过我们一般不会用到。\n"),r("img",{attrs:{src:"/img/vue-4-4.png",alt:"在这里插入图片描述"}})]),e._v(" "),r("p",[e._v("那么还有两个生命周期方法 activated 和 deactivated。")]),e._v(" "),r("p",[e._v("Vue 里面有个原生的组件，叫做 keep-alive。那么这两个生命周期方法就和它有关系。")]),e._v(" "),r("p",[e._v("这两个方法我们会在后面的组件进行详细的讲解。")]),e._v(" "),r("p",[e._v("生命周期大致就是这些内容，但是有一些东西是需要大家去注意的。")]),e._v(" "),r("p",[e._v("我们可以尝试下，在 beforeCreate，created，beforeMount，mounted 里面打印 this.$el，看下它是什么东西：")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/vue-4-5.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到， beforeCreate 和 created，它的 this.$el 都是 undefined。")]),e._v(" "),r("p",[e._v("在 beforeMount 的时候，它的 this.$el 就是我们写在 html 里面的 div 节点。")]),e._v(" "),r("p",[e._v("等到 mounted 的时候，它的节点就变成了我们这边渲染出来的 html（就是 template 里面的代码），然后把 beforeMount 里面的 $el 给覆盖掉。")]),e._v(" "),r("p",[e._v("因此，我们在 beforeCreate 和 created 是拿不到 this.$el 的，所以我们在这两个方法执行的时候，如果你要去做相应的一些 DOM 操作，你是没有办法去做的。因为你根本拿不到组件对应的节点。")]),e._v(" "),r("p",[e._v("所以，一般我们要去做一些和 DOM 有关的东西，我们都会把它放到 mounted 里面。")]),e._v(" "),r("p",[e._v("然后跟数据有关的一些东西，可以放在 created 或者 mounted 里面，这些都是差不多的。")]),e._v(" "),r("p",[e._v("我们看到的 beforeCreate，created，beforeMount，mounted。它们都是一次性的。也就是说它们只会被调用一次。")]),e._v(" "),r("p",[e._v("而且 beforeMount 和 mounted 这两个方法，在服务端渲染的时候，是不会被调用的。因为 mount 是要跟 DOM 操作有关的。")]),e._v(" "),r("p",[e._v("服务端渲染根本没有 DOM 执行的环境，所以就不会执行。")]),e._v(" "),r("p",[e._v("接下来，让我们看下官方的生命周期图示：\n"),r("img",{attrs:{src:"/img/vue-4-6.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到，在 new 一个 Vue 对象的过程当中，首先它执行了 init()，那么在 init() 的过程中，它先调用了 beforeCreate。")]),e._v(" "),r("p",[e._v("然后在 injections 和 reactivity 的时候，再去调用 created。")]),e._v(" "),r("p",[e._v("因此，在 beforeCreate 的时候，它的事件是已经 OK 了，但是它的 reactivity 还没有好。所以在 beforeCreate 中，不要去修改 data 中的数据。")]),e._v(" "),r("p",[e._v("你如果要做一些 ajax 的请求，或者去给组件上面赋一些新的值，那么你最早也要放在 created 里面去做。")]),e._v(" "),r("p",[e._v("接下来，它会判断是否有 el option。也就是我们写的 el: '#app'。如果没有的话，它会等着我们去调用 app.$mount(el) 这个方法。")]),e._v(" "),r("p",[e._v("然后在执行下一步，判断是否有 template option，就是我们写的 template: "),r("code",[e._v("<div>...</div>")]),e._v("。")]),e._v(" "),r("p",[e._v("如果有这个属性，它会把 template 解析成一个 render function。就是我们在之前写的 render (h) { return h(...) }。")]),e._v(" "),r("p",[e._v("我们可以不写 template，试试 render 方法：\n"),r("img",{attrs:{src:"/img/vue-4-7.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到，这个结果和我们写的 template，解析出来的结果是一模一样的。")]),e._v(" "),r("p",[e._v("那么 render 是在什么时候执行的呢？\n"),r("img",{attrs:{src:"/img/vue-4-8.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到，render 方法是在 beforeMount 和 mounted 之间去执行的，这其实也就证明了：")]),e._v(" "),r("p",[e._v("在 beforeMount 的时候，我们写的 $el 还只是我们在 html 里面写的那个节点。")]),e._v(" "),r("p",[e._v("然后到 mounted 的时候，它已经变成了我们真正渲染出来的结果。")]),e._v(" "),r("p",[e._v("这中间就是做了 render function 的内容，导致了 mounted 会变成一个新的结果。")]),e._v(" "),r("p",[e._v("那么在我们使用 .vue 文件开发的过程中，是都没有 template 的。")]),e._v(" "),r("p",[e._v("其实我们在 .vue 文件里面写的 template，都经过 vue-loader 的处理，直接变成了一个 render function，放在了 vue-loader 解析过的文件里面。")]),e._v(" "),r("p",[e._v("那么这样做有什么好处呢？因为解析 template 变成一个 render function，这中间是比较耗时的一个过程。")]),e._v(" "),r("p",[e._v("所以 vue-loader 帮我们处理了这些内容之后，我们在页面上执行 vue 代码的时候，它的效率会变的更高。")]),e._v(" "),r("p",[e._v("那么回到正题，beforeMount 就在我们有了 render function 的时候，它才去执行，这中间就是执行了 render function。之后就调用了 mounted。")]),e._v(" "),r("p",[e._v("在 mounted 之后，其实这个实例已经创建完成了，后续的过程都是要通过一些外部的触发才会去做的。")]),e._v(" "),r("p",[e._v("比如说有数据的变化，那么会调用 beforeUpdate 和 updated。")]),e._v(" "),r("p",[e._v("如果我们的组件调用了 $destroy() 或者是被销毁，它会调用 beforeDestroy 和 destroyed。")]),e._v(" "),r("p",[e._v("这就是我们整个 Vue 实例，从新建到销毁，整个流程，以及它会触发哪些声明周期的方法。")]),e._v(" "),r("p",[e._v("其实 Vue 还提供给我们一个叫 renderError 的方法。这个方法只有在我们开发的时候才会被调用。")]),e._v(" "),r("p",[e._v("我们在正式打包上线的时候，它是不会被调用的。它的目的就是帮我们去更容易的调试一些 render 里面的错误。")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/vue-4-9.png",alt:"在这里插入图片描述"}}),e._v("\n我们可以看到，这时候渲染出来的，就是 err 信息了。")]),e._v(" "),r("p",[e._v("renderError 只有在本组件出现错误的时候，它才会被调用。")]),e._v(" "),r("p",[e._v("如果这个组件，它下面有子组件，子组件的报错，是不会被它捕获到的。它只关心自己有没有渲染成功。")]),e._v(" "),r("p",[e._v("那么相对应的，还有个 errorCaptured 的方法。它是可以用到正式开发环境里的。")]),e._v(" "),r("p",[e._v("它可以帮助我们去收集线上的一些错误，而且如果我们只在根组件上写了这个方法，那么它所有的子组件，如果有任何一个组件报了错，它都可以捕捉到。")]),e._v(" "),r("p",[e._v("除非报错的子组件，把它向上冒泡的事件，给停止掉。")]),e._v(" "),r("p",[e._v("renderError 和 errorCaptured 它们的用法基本是一样的。唯一的区别就是 errorCaptured 会向上冒泡，并且正式环境可以使用。")]),e._v(" "),r("p",[e._v("那么以上就是关于 Vue 生命周期方法的一些内容。那么大家要记住的就是：")]),e._v(" "),r("h4",{attrs:{id:"_1，执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1，执行顺序"}},[e._v("#")]),e._v(" 1，执行顺序")]),e._v(" "),r("h4",{attrs:{id:"_2，它们什么时候会被调用，你可以做哪些操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2，它们什么时候会被调用，你可以做哪些操作"}},[e._v("#")]),e._v(" 2，它们什么时候会被调用，你可以做哪些操作")]),e._v(" "),r("h4",{attrs:{id:"_3，它们上面的-this-对象有哪些区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3，它们上面的-this-对象有哪些区别"}},[e._v("#")]),e._v(" 3，它们上面的 this 对象有哪些区别")])])}),[],!1,null,null,null);t.default=_.exports}}]);