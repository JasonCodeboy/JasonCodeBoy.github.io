(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{393:function(t,v,_){"use strict";_.r(v);var e=_(33),p=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"computed，watch"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#computed，watch"}},[t._v("#")]),t._v(" computed，watch")]),t._v(" "),_("p",[t._v("我们首先来看个小例子，名字的显示：\n"),_("img",{attrs:{src:"/img/vue-6-1.png",alt:"在这里插入图片描述"}}),t._v("\n在这种比较简单的情况下，我们这样做是没有任何问题的，但是有一些复杂的情况，比如说计算比较多，我们可能会根据业务逻辑的不同，会有一些比较复杂的计算。")]),t._v(" "),_("p",[t._v("你拿到的数据会有很多份，然后你要显示的时候，还要把这些数据进行一些处理，再把它拼接起来，最终成为一个你要显示的数据。")]),t._v(" "),_("p",[t._v("在这种情况下，到 template 模版里面写就不太合适了，这个时候，我们一般就会用 computed。")]),t._v(" "),_("p",[t._v("computed 它是一个对象，在这个对象里面，你可以去声明很多的方法，那么这些方法返回的数据，你可以直接通过像我们去调用变量一样，直接在 template 模版里面去调用。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/vue-6-2.png",alt:"在这里插入图片描述"}})]),t._v(" "),_("p",[t._v("我们可以看到，结果是一模一样的。")]),t._v(" "),_("p",[t._v("那么为什么可以这样写呢？因为 computed 它其实就是一个 get 方法。")]),t._v(" "),_("p",[t._v("那么什么是 get 方法呢？其实就是通过 Object.defineProperty 给它设置一个 getter 和 setter 方法。")]),t._v(" "),_("p",[t._v("然后 getter 方法，你可以通过变量的名字去调用，但实际上，你调用的是这一个方法。")]),t._v(" "),_("p",[t._v("当然 Vue 里面肯定会有更复杂的处理，因为 computed 里面是有缓存的。我们每一次通过字符串拼接，其实就是一次计算。")]),t._v(" "),_("p",[t._v("那么，如果我们每一次模版渲染的时候，都要去计算一次，那么这个性能开销就会比较大。")]),t._v(" "),_("p",[t._v("所以 computed 里面就会做一个缓存，让我们避免这种问题。")]),t._v(" "),_("p",[t._v("我们可以在 methods 里面定义一个方法，也可以达到同样的效果，那么使用 computed 的好处在哪里呢？")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/vue-6-3.png",alt:"在这里插入图片描述"}}),t._v("\n我们在改变 num 的时候，整个应用会重新渲染，因为它要把 num 新的值显示到 DOM 里面。")]),t._v(" "),_("p",[t._v("那这个时候，如果我们使用的是 getName 方法，那么这个方法它就会被重新调用。也就是说它要重新经过计算，在渲染。")]),t._v(" "),_("p",[t._v("而 computed 它是不会重新调用我们这个方法的。")]),t._v(" "),_("p",[t._v("这里我们的计算量非常的小，只是做了一个字符串拼接，但是如果我们新的值要经过非常大量的计算才能得到，那么缓存的意义就变的非常大。")]),t._v(" "),_("p",[t._v("所以 computed 其实是可以给我们应用的性能带来很大的影响。")]),t._v(" "),_("p",[t._v("那么如果 computed 里面依赖的值有任何一个变化了，它就会去重新计算一次，得到一个新的值在缓存起来。这就是 computed 的意义。")]),t._v(" "),_("p",[t._v("那么 computed 我们一般用在什么地方呢？就是我们拿到的这部分数据，并不是我们真正的想要去显示的数据。")]),t._v(" "),_("p",[t._v("而是要通过一次计算，把几个数据拼接起来，或者经过处理，再得到这个数据去显示。")]),t._v(" "),_("p",[t._v("这个时候我们用 computed 就会非常的方便。")]),t._v(" "),_("p",[t._v("当然，computed 也可以做设置的操作：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/vue-6-4.png",alt:"在这里插入图片描述"}}),t._v("\n我们可以看到，当我们在输入框中改变它们的时候，上面也是跟着一起变的。")]),t._v(" "),_("p",[t._v("所以，computed 它也可以做设置的操作，但是，一般我不推荐你去这么做。")]),t._v(" "),_("p",[t._v("因为 computed 是根据多重数据组合而来的一个新数据。组合很容易，但是你要拆开来，在给它们分别去设值，就会变的非常复杂。")]),t._v(" "),_("p",[t._v("一不小心弄错，可能就会导致 computed 重复计算，然后就变成一个死循环，会理不清楚里面的逻辑。")]),t._v(" "),_("p",[t._v("所以一般来说，我的建议是，不到万不得已只能这么做的情况，你都不要去用 computed 的 set 方法。")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("那么还有一个和 computed 比较类似的，就是 watch：\n"),_("img",{attrs:{src:"/img/vue-6-5.png",alt:"在这里插入图片描述"}}),t._v("\n我们可以看到，刚开始默认的情况下（左侧图），FullName 是没有的。当我们输入了 1 之后，它才有了（右侧图）。")]),t._v(" "),_("p",[t._v("这是为什么呢？因为 watch 方法，你最初绑定的时候，它是不会执行的。如果你要它执行，就需要通过另一种方法来做：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/vue-6-6.png",alt:"在这里插入图片描述"}}),t._v("\nhandler 就是我们平常默认写的方法，Vue 会将我们平常默认写的方法最终编译出来，就是 handler。")]),t._v(" "),_("p",[t._v("immediate: true，代表我们声明这个属性之后，在 watch 里面我们要去监听 firstName 的话，就会立刻先去执行一次 handler。")]),t._v(" "),_("p",[t._v("如果我们没有声明 immediate，那么它在绑定的时候是不会去执行的。只会在下次有变化的时候，才执行 handler。")]),t._v(" "),_("hr"),t._v(" "),_("p",[t._v("watch 相比于 computed：")]),t._v(" "),_("p",[t._v("我们可以看到 watch 明显的劣势，如果我要得到一个新的值，要去根据 firstName 和 lastName，就要去监听这 2 个值。")]),t._v(" "),_("p",[t._v("那么我就要加两个 handler，写的代码也要多一倍。所以 watch 并不适用于我们要去显示某一个数据，去做一个数据的拼接。")]),t._v(" "),_("p",[t._v("这种情况，用 computed 是最好的，并且它性能也好。")]),t._v(" "),_("p",[t._v("watch 更多的时候，比如说你监听到了一个值的变化，然后你要去给后台发一个请求，那么这种情况 computed 就做不到了。")]),t._v(" "),_("p",[t._v("只能通过 watch 的方式去做。所以 watch 的主要场景是，你监听到了某一个数据的变化，然后去做某一个指定的操作。")]),t._v(" "),_("p",[t._v("watch 里面还有一个属性 deep，它的默认值是 false。")]),t._v(" "),_("p",[t._v("那么 deep 是用在什么时候呢？我们先看下面一张图：\n"),_("img",{attrs:{src:"/img/vue-6-7.png",alt:"在这里插入图片描述"}}),t._v("\n我们可以看到，当我们输入的时候，obj.a 监听并没有触发，我们已经监听到了 obj 了，那为什么 obj 里面的东西变化了，却并没有调用 handler 呢？")]),t._v(" "),_("p",[t._v("因为它是一个对象，对象里面有很多的属性。默认情况下，handler 它只监听 obj 这个引用的变化。")]),t._v(" "),_("p",[t._v("意思就是我们只有给 obj 重新赋值的时候，它才会监听到。")]),t._v(" "),_("p",[t._v("那么改它内部的属性，如何触发 watch 呢？那就是 deep：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/img/vue-6-8.png",alt:"在这里插入图片描述"}}),t._v("\ndeep 的意思就是：深入观察。")]),t._v(" "),_("p",[t._v("我们加了 deep 之后，watch 对象就会把 obj 下面的所有属性都遍历了一遍，而且是一层一层的往下遍历，给所有的属性都加上了监听事件。")]),t._v(" "),_("p",[t._v("那么这样的性能开销就会很大，因为你每次修改 obj 里面的任何一个地方，它都会触发 handler。")]),t._v(" "),_("p",[t._v("那么有没有什么办法去优化它呢？\n"),_("img",{attrs:{src:"/img/vue-6-9.png",alt:"在这里插入图片描述"}}),t._v("\n我们可以把要监听的值，写成一个字符串 'obj.a'。")]),t._v(" "),_("p",[t._v("我们可以在字符串里面去写这个对象的深入的属性调用，它会一层一层解析下去，最终解析到我们写的那个属性，然后它才去监听我们真正需要监听的属性。")]),t._v(" "),_("p",[t._v("最后，大家还要注意一个非常重要的点，就是千万不要在 computed 和 watch 里面去修改你依赖的那个值。特别是 computed 里面。")]),t._v(" "),_("p",[t._v("在 computed 和 watch 里面，最好不要去做任何值的修改。你尽量只是做到去生成一个新的值，但是你不要去修改原来的任何属性。如果你做了一些修改，那么可能会导致一个无限循环的触发。")]),t._v(" "),_("p",[t._v("那么你需要做的就是：控制你在 computed 和 watch 里面，尽量不要去改值。它们应该是一个监听，然后处理成一个新的值的功能。而不是你监听了之后，要去改某一个属性。")]),t._v(" "),_("p",[t._v("当然有时，在 watch 里面也会碰到这种需求，那么你要控制不要改你监听的任何相关的属性就 OK 了。")])])}),[],!1,null,null,null);v.default=p.exports}}]);